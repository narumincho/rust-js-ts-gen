use crate::data;

/// 入れ子の回数
struct Indent {
    value: u16,
}

impl Indent {
    fn zero() -> Self {
        Indent { value: 0 }
    }

    fn add_one(&self) -> Self {
        Indent {
            value: self.value + 1,
        }
    }
}

const ESLINT_DISABLE_COMMENT: &'static str =
    "/* eslint-disable */\n/* generated by js-ts-code-generator. Do not edit! */\n\n";

/// コードを文字列にする
pub fn to_string(code: &data::Code, code_type: &data::CodeType) -> String {
    let mut result = String::new();
    result.push_str(ESLINT_DISABLE_COMMENT);
    vec_to_string(
        &mut result,
        &code.export_definition_list,
        |mut r, export_definition| {
            export_definition_to_string(&mut r, &export_definition, code_type)
        },
        "\n",
    );
    if code.statement_list.is_empty() {
        result
    } else {
        result.push_str(&statement_list_to_string(
            &code.statement_list,
            &Indent::zero(),
            code_type,
        ));
        result
    }
}

fn export_definition_to_string(
    builder: &mut String,
    export_definition: &data::ExportDefinition,
    code_type: &data::CodeType,
) {
    match export_definition {
        data::ExportDefinition::TypeAlias(type_alias) => match &code_type {
            data::CodeType::JavaScript => {}
            data::CodeType::TypeScript => builder.push_str(&type_alias_to_string(type_alias)),
        },
        data::ExportDefinition::Function(function) => {
            export_function_to_string(builder, function, code_type)
        }
        data::ExportDefinition::Variable(variable) => {
            builder.push_str(&export_variable_to_string(variable, code_type))
        }
    }
}

fn type_alias_to_string(type_alias: &data::TypeAlias) -> String {
    let mut builder = String::new();
    document_to_string(&mut builder, &type_alias.document);
    builder
        + "export type "
        + &type_alias.name.get()
        + &type_parameter_list_to_string(
            &type_alias.type_parameter_list,
            &data::CodeType::TypeScript,
        )
        + " = "
        + &type_to_string(&type_alias.r#type)
        + ";\n\n"
}

fn export_function_to_string(
    builder: &mut String,
    function: &data::Function,
    code_type: &data::CodeType,
) {
    document_to_string(
        builder,
        &(String::new()
            + &function.document
            + &parameter_list_to_document(&function.parameter_list)),
    );
    builder.push_str("export const ");
    builder.push_str(&function.name.get());
    builder.push_str(" = ");
    builder.push_str(&type_parameter_list_to_string(
        &function.type_parameter_list,
        code_type,
    ));
    builder.push_str("(");
    vec_to_string(
        builder,
        &function.parameter_list,
        |r, parameter| {
            r.push_str(&(parameter.name.get() + &type_annotation(&parameter.r#type, code_type)))
        },
        ", ",
    );
    builder.push_str(")");
    builder.push_str(&type_annotation(&function.return_type, code_type));
    builder.push_str(" => ");
    builder.push_str(&lambda_body_to_string(
        &function.statement_list,
        &Indent::zero(),
        code_type,
    ));
    builder.push_str(";\n\n");
}

fn export_variable_to_string(variable: &data::Variable, code_type: &data::CodeType) -> String {
    let mut builder = String::new();
    document_to_string(&mut builder, &variable.document);
    builder
        + "export const "
        + &variable.name.get()
        + &type_annotation(&variable.r#type, code_type)
        + " = "
        + &expr_to_string(&variable.expr, &Indent::zero(), code_type)
        + ";\n\n"
}

fn document_to_string(builder: &mut String, document: &str) {
    let trimmed = document.trim();
    if trimmed.is_empty() {
        return;
    }
    builder.push_str("\n/**\n");
    vec_to_string(
        builder,
        &trimmed.lines().collect::<Vec<&str>>(),
        |builder, line| {
            builder.push_str(" *");
            if !line.is_empty() {
                builder.push(' ');
                builder.push_str(line)
            }
        },
        "\n",
    );
    builder.push_str("\n */\n");
}

fn parameter_list_to_document(parameter_list: &Vec<data::ParameterWithDocument>) -> String {
    if parameter_list.is_empty() {
        String::new()
    } else {
        String::from("\n")
            + &parameter_list
                .iter()
                .map(|parameter| {
                    if parameter.document.is_empty() {
                        String::new()
                    } else {
                        String::from("@param ") + &parameter.name.get() + " " + &parameter.document
                    }
                })
                .collect::<Vec<String>>()
                .join("\n")
    }
}

/// 型パラメーターを文字列にする
///
/// - `<T extends unknown>`
/// - `<ok extends unknown, error extends unknown>`
///
///
/// extends unknown をつけた理由はJSXでも解釈できるようにするため
fn type_parameter_list_to_string(
    type_parameter_list: &Vec<data::identifer::Identifer>,
    code_type: &data::CodeType,
) -> String {
    if *code_type == data::CodeType::JavaScript || type_parameter_list.is_empty() {
        String::new()
    } else {
        String::from("<")
            + &type_parameter_list
                .iter()
                .map(|type_parameter| type_parameter.get() + " extends unknown")
                .collect::<Vec<String>>()
                .join(", ")
            + ">"
    }
}

fn type_to_string(r#type: &data::Type) -> String {
    match r#type {
        data::Type::Number => String::from("number"),

        data::Type::String => String::from("string"),

        data::Type::Boolean => String::from("boolean"),

        data::Type::Null => String::from("null"),

        data::Type::Never => String::from("never"),

        data::Type::Void => String::from("void"),

        data::Type::Undefined => String::from("undefined"),

        data::Type::Object(member_list) => type_object_to_string(&**member_list),

        data::Type::Function(function_type) => type_function_to_string(function_type),

        data::Type::Union(type_list) => type_list
            .iter()
            .map(|pattern| type_to_string(pattern))
            .collect::<Vec<String>>()
            .join(" | "),

        data::Type::Intersection(intersection_type) => {
            type_to_string(&intersection_type.left)
                + " & "
                + &type_to_string(&intersection_type.right)
        }

        data::Type::WithTypeParameter(type_with_parameter) => {
            type_to_string(&type_with_parameter.r#type)
                + &(if type_with_parameter.type_parameter_list.is_empty() {
                    String::new()
                } else {
                    String::from("<")
                        + &type_with_parameter
                            .type_parameter_list
                            .iter()
                            .map(type_to_string)
                            .collect::<Vec<String>>()
                            .join(", ")
                        + ">"
                })
        }

        data::Type::ScopeInFile(identifer) => identifer.get(),

        data::Type::ScopeInGlobal(identifer) => identifer.get(),
        data::Type::ImportedType(imported_type) => {
            String::from("$$$") + &imported_type.module_name + "." + &imported_type.name.get()
        }

        data::Type::StringLiteral(string) => string_literal_value_to_string(string),
    }
}

fn lambda_body_to_string(
    statement_list: &Vec<data::Statement>,
    indent: &Indent,
    code_type: &data::CodeType,
) -> String {
    match statement_list.first() {
        Some(data::Statement::Return(expr)) if statement_list.len() == 1 => {
            expr_to_string_with_combine_strength(LAMBDA_COMBINE_STRENGTH, expr, indent, code_type)
        }
        _ => statement_list_to_string(statement_list, indent, code_type),
    }
}

fn expr_to_string(expr: &data::Expr, indent: &Indent, code_type: &data::CodeType) -> String {
    match expr {
        data::Expr::NumberLiteral(int32) => format!("{}", int32),

        data::Expr::StringLiteral(string) => string_literal_value_to_string(string),

        data::Expr::BooleanLiteral(true) => String::from("true"),

        data::Expr::BooleanLiteral(false) => String::from("false"),

        data::Expr::UndefinedLiteral => String::from("undefined"),

        data::Expr::NullLiteral => String::from("null"),

        data::Expr::ArrayLiteral(array_item) => {
            array_literal_to_string(array_item, indent, code_type)
        }

        data::Expr::ObjectLiteral(member_list) => {
            object_literal_to_string(member_list, indent, code_type)
        }

        data::Expr::UnaryOperator(unary_operator_expr) => {
            unary_operator_to_string(&unary_operator_expr.operator)
                + &expr_to_string_with_combine_strength(
                    UNARY_OPERATOR_COMBINE_STRENGTH,
                    &unary_operator_expr.expr,
                    indent,
                    code_type,
                )
        }
        data::Expr::BinaryOperator(binary_operator_expr) => {
            binary_operator_expr_to_string(binary_operator_expr, indent, code_type)
        }

        data::Expr::ConditionalOperator(conditional_operator_expr) => {
            conditional_operator_expr_to_string(conditional_operator_expr, indent, code_type)
        }

        data::Expr::Lambda(lambda) => {
            type_parameter_list_to_string(&lambda.type_parameter_list, code_type)
                + "("
                + &lambda
                    .parameter_list
                    .iter()
                    .map(|parameter| {
                        parameter.name.get() + &type_annotation(&parameter.r#type, code_type)
                    })
                    .collect::<Vec<String>>()
                    .join(", ")
                + ")"
                + &type_annotation(&lambda.return_type, code_type)
                + " => "
                + &lambda_body_to_string(&lambda.statement_list, indent, code_type)
        }

        data::Expr::Variable(identifer) => identifer.get(),

        data::Expr::GlobalObjects(identifer) => identifer.get(),
        data::Expr::ImportedVariable(imported_variable) => {
            String::from("$$$")
                + &imported_variable.module_name
                + "."
                + &imported_variable.name.get()
        }

        data::Expr::Get(get_expr) => {
            expr_to_string_with_combine_strength(
                GET_COMBINE_STRENGTH,
                &get_expr.expr,
                indent,
                code_type,
            ) + &index_access_to_string(&get_expr.property_expr, indent, code_type)
        }

        data::Expr::Call(call_expr) => call_expr_to_string(call_expr, indent, code_type),

        data::Expr::New(call_expr) => {
            String::from("new ") + &call_expr_to_string(call_expr, indent, code_type)
        }

        data::Expr::TypeAssertion(type_assertion) => {
            expr_to_string(&type_assertion.expr, indent, code_type)
                + " as "
                + &type_to_string(&type_assertion.r#type)
        }
    }
}

fn expr_to_string_with_combine_strength(
    outside_combine_strength: u8,
    target: &data::Expr,
    indent: &Indent,
    code_type: &data::CodeType,
) -> String {
    enclose_in_parentheses_by_condition(
        &expr_to_string(target, indent, code_type),
        outside_combine_strength > expr_combine_strength(target),
    )
}

fn enclose_in_parentheses_by_condition(str: &str, condition: bool) -> String {
    if condition {
        String::from("(") + str + ")"
    } else {
        String::from(str)
    }
}

/// https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table
fn expr_combine_strength(expr: &data::Expr) -> u8 {
    match expr {
        data::Expr::NumberLiteral(_)
        | data::Expr::StringLiteral(_)
        | data::Expr::BooleanLiteral(_)
        | data::Expr::NullLiteral
        | data::Expr::UndefinedLiteral
        | data::Expr::ArrayLiteral(_)
        | data::Expr::Variable(_)
        | data::Expr::GlobalObjects(_)
        | data::Expr::ImportedVariable(_) => 23,
        data::Expr::Lambda(_) => LAMBDA_COMBINE_STRENGTH,
        data::Expr::ObjectLiteral(_) => 21,
        data::Expr::Get(_) => GET_COMBINE_STRENGTH,
        data::Expr::Call(_) | data::Expr::New(_) => CALL_OR_NEW_COMBINE_STRENGTH,
        data::Expr::UnaryOperator(_) => UNARY_OPERATOR_COMBINE_STRENGTH,
        data::Expr::BinaryOperator(binary_operator_expr) => {
            binary_operator_combine_strength(&binary_operator_expr.operator)
        }
        data::Expr::ConditionalOperator(_) => CONDITIONAL_OPERATOR_COMBINE_STRENGTH,
        data::Expr::TypeAssertion(_) => 3,
    }
}

const LAMBDA_COMBINE_STRENGTH: u8 = 22;
const UNARY_OPERATOR_COMBINE_STRENGTH: u8 = 17;
const GET_COMBINE_STRENGTH: u8 = 20;
const CALL_OR_NEW_COMBINE_STRENGTH: u8 = 20;
const CONDITIONAL_OPERATOR_COMBINE_STRENGTH: u8 = 4;

/// https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table
fn binary_operator_combine_strength(binary_operator: &data::BinaryOperator) -> u8 {
    match binary_operator {
        data::BinaryOperator::Exponentiation => 16,
        data::BinaryOperator::Multiplication
        | data::BinaryOperator::Division
        | data::BinaryOperator::Remainder => 15,
        data::BinaryOperator::Addition | data::BinaryOperator::Subtraction => 14,
        data::BinaryOperator::LeftShift
        | data::BinaryOperator::SignedRightShift
        | data::BinaryOperator::UnsignedRightShift => 13,
        data::BinaryOperator::LessThan | data::BinaryOperator::LessThanOrEqual => 12,
        data::BinaryOperator::Equal | data::BinaryOperator::NotEqual => 11,
        data::BinaryOperator::BitwiseAnd => 10,
        data::BinaryOperator::BitwiseXOr => 9,
        data::BinaryOperator::BitwiseOr => 8,
        data::BinaryOperator::LogicalAnd => 6,
        data::BinaryOperator::LogicalOr => 5,
    }
}

fn statement_list_to_string(
    statement_list: &Vec<data::Statement>,
    indent: &Indent,
    code_type: &data::CodeType,
) -> String {
    String::from("{\n")
        + &statement_list
            .iter()
            .map(|statement| statement_to_string(statement, &indent.add_one(), code_type))
            .collect::<Vec<String>>()
            .join("\n")
        + "\n"
        + &indent_number_to_string(indent)
        + "}"
}

fn statement_to_string(
    statement: &data::Statement,
    indent: &Indent,
    code_type: &data::CodeType,
) -> String {
    indent_number_to_string(indent)
        + &(match statement {
            data::Statement::EvaluateExpr(expr) => expr_to_string(expr, indent, code_type) + ";",
            data::Statement::Set(set_statement) => {
                expr_to_string(&set_statement.target, indent, code_type)
                    + " "
                    + &(match &set_statement.operator_maybe {
                        Some(operator) => binary_operator_to_string(operator),
                        None => String::from(""),
                    })
                    + "= "
                    + &expr_to_string(&set_statement.expr, indent, code_type)
                    + ";"
            }
            data::Statement::If(if_statement) => {
                String::from("if (")
                    + &expr_to_string(&if_statement.condition, indent, code_type)
                    + ") "
                    + &statement_list_to_string(
                        &if_statement.then_statement_list,
                        indent,
                        code_type,
                    )
            }
            data::Statement::ThrowError(expr) => {
                String::from("throw new Error(") + &expr_to_string(expr, indent, code_type) + ");"
            }
            data::Statement::Return(expr) => {
                String::from("return ") + &expr_to_string(expr, indent, code_type) + ";"
            }
            data::Statement::ReturnVoid => String::from("return;"),
            data::Statement::Continue => String::from("continue;"),
            data::Statement::VariableDefinition(variable_definition_statement) => {
                String::from(if variable_definition_statement.is_const {
                    "const"
                } else {
                    "let"
                }) + " "
                    + &variable_definition_statement.name.get()
                    + &type_annotation(&variable_definition_statement.r#type, code_type)
                    + " = "
                    + &expr_to_string(&variable_definition_statement.expr, indent, code_type)
                    + ";"
            }
            data::Statement::FunctionDefinition(function_definition_statement) => {
                function_definition_statement_to_string(
                    function_definition_statement,
                    indent,
                    code_type,
                )
            }

            data::Statement::For(for_statement) => {
                String::from("for (let ")
                    + &for_statement.counter_variable_name.get()
                    + " = 0; "
                    + &for_statement.counter_variable_name.get()
                    + " < "
                    + &expr_to_string(&for_statement.until_expr, indent, code_type)
                    + "; "
                    + &for_statement.counter_variable_name.get()
                    + " += 1)"
                    + &statement_list_to_string(&for_statement.statement_list, indent, code_type)
            }
            data::Statement::ForOf(for_of_statement) => {
                String::from("for (const ")
                    + &for_of_statement.element_variable_name.get()
                    + " of "
                    + &expr_to_string(&for_of_statement.iterable_expr, indent, code_type)
                    + ")"
                    + &statement_list_to_string(&for_of_statement.statement_list, indent, code_type)
            }
            data::Statement::WhileTrue(statement_list) => {
                String::from("while (true) ")
                    + &statement_list_to_string(statement_list, indent, code_type)
            }

            data::Statement::Break => String::from("break"),
            data::Statement::Switch(switch_statement) => {
                switch_to_string(switch_statement, indent, code_type)
            }
        })
}

fn binary_operator_to_string(binary_operator: &data::BinaryOperator) -> String {
    String::from(match binary_operator {
        data::BinaryOperator::Exponentiation => "**",
        data::BinaryOperator::Multiplication => "*",
        data::BinaryOperator::Division => "/",
        data::BinaryOperator::Remainder => "%",
        data::BinaryOperator::Addition => "+",
        data::BinaryOperator::Subtraction => "-",
        data::BinaryOperator::LeftShift => "<<",
        data::BinaryOperator::SignedRightShift => ">>",
        data::BinaryOperator::UnsignedRightShift => ">>>",
        data::BinaryOperator::LessThan => "<",
        data::BinaryOperator::LessThanOrEqual => "<=",
        data::BinaryOperator::Equal => "===",
        data::BinaryOperator::NotEqual => "!==",
        data::BinaryOperator::BitwiseAnd => "&",
        data::BinaryOperator::BitwiseXOr => "^",
        data::BinaryOperator::BitwiseOr => "|",
        data::BinaryOperator::LogicalAnd => "&&",
        data::BinaryOperator::LogicalOr => "||",
    })
}

fn indent_number_to_string(indent: &Indent) -> String {
    String::from("  ").repeat(indent.value as usize)
}

/**
 * codeTypeがTypeScriptだった場合,`: string`のような型注釈をつける
 */
fn type_annotation(r#type: &data::Type, code_type: &data::CodeType) -> String {
    match code_type {
        data::CodeType::JavaScript => String::new(),
        data::CodeType::TypeScript => String::from(": ") + &type_to_string(&r#type),
    }
}

fn type_object_to_string(member_list: &Vec<data::MemberType>) -> String {
    String::from("{ ")
        + &member_list
            .iter()
            .map(|member| {
                let mut builder = String::new();
                document_to_string(&mut builder, &member.document);

                builder
                    + "readonly "
                    + &property_name_to_string(&member.name)
                    + &(if member.required { "" } else { "?" })
                    + ": "
                    + &type_to_string(&member.r#type)
            })
            .collect::<Vec<String>>()
            .join("; ")
        + " }"
}

/// 関数の引数と戻り値の型を文字列にする
fn type_function_to_string(function_type: &data::FunctionType) -> String {
    type_parameter_list_to_string(
        &function_type.type_parameter_list,
        &data::CodeType::TypeScript,
    ) + "("
        + &function_type
            .parameter_list
            .iter()
            .enumerate()
            .map(|(index, parameter)| format!("${}: {}", index, type_to_string(parameter)))
            .collect::<Vec<String>>()
            .join(", ")
        + ") => "
        + &type_to_string(&function_type.return_type)
}

fn string_literal_value_to_string(string: &str) -> String {
    String::from("\"")
        + &string
            .replace("\\", "\\\\")
            .replace("\"", "\\\"")
            .replace("\n", "\\n")
        + "\""
}

#[test]
fn test_escape_in_string_literal() {
    assert_eq!(
        string_literal_value_to_string(
            r#"\\ a
\"""#
        ),
        String::from(r#""\\\\ a\n\\\"\"""#)
    );
    assert_eq!(
        string_literal_value_to_string(
            r#"
        改行
        "ダブルクオーテーション"
"#
        ),
        String::from(r#""\n        改行\n        \"ダブルクオーテーション\"\n""#)
    )
}

fn array_literal_to_string(
    item_list: &Vec<data::ArrayItem>,
    indent: &Indent,
    code_type: &data::CodeType,
) -> String {
    String::from("[")
        + &item_list
            .iter()
            .map(|item| {
                String::from(if item.spread { "..." } else { "" })
                    + &expr_to_string(&item.expr, indent, code_type)
            })
            .collect::<Vec<String>>()
            .join(", ")
        + "]"
}

fn object_literal_to_string(
    member_list: &Vec<data::Member>,
    indent: &Indent,
    code_type: &data::CodeType,
) -> String {
    String::from("{ ")
        + &member_list
            .iter()
            .map(|member| match member {
                data::Member::Spread(expr) => {
                    String::from("...") + &expr_to_string(expr, indent, code_type)
                }

                data::Member::KeyValue(data::KeyValue {
                    key,
                    value: data::Expr::Variable(value_identifer),
                }) if *key == value_identifer.get() => key.clone(),
                data::Member::KeyValue(data::KeyValue { key, value }) => {
                    (property_name_to_string(key))
                        + ": "
                        + &expr_to_string(value, indent, code_type)
                }
            })
            .collect::<Vec<String>>()
            .join(", ")
        + " "
        + "}"
}

fn unary_operator_to_string(unary_operator: &data::UnaryOperator) -> String {
    String::from(match unary_operator {
        data::UnaryOperator::Minus => "-",
        data::UnaryOperator::BitwiseNot => "~",
        data::UnaryOperator::LogicalNot => "!",
    })
}

fn binary_operator_expr_to_string(
    binary_operator_expr: &data::BinaryOperatorExpr,
    indent: &Indent,
    code_type: &data::CodeType,
) -> String {
    let operator_expr_combine_strength =
        binary_operator_combine_strength(&binary_operator_expr.operator);
    let left_expr_combine_strength = expr_combine_strength(&binary_operator_expr.left);
    let right_expr_combine_strength = expr_combine_strength(&binary_operator_expr.right);
    let associativity = binary_operator_associativity(&binary_operator_expr.operator);

    (enclose_in_parentheses_by_condition(
        &expr_to_string(&binary_operator_expr.left, indent, code_type),
        operator_expr_combine_strength > left_expr_combine_strength
            || (operator_expr_combine_strength == left_expr_combine_strength
                && associativity == Associativity::RightToLeft),
    )) + " "
        + &binary_operator_to_string(&binary_operator_expr.operator)
        + " "
        + &(enclose_in_parentheses_by_condition(
            &expr_to_string(&binary_operator_expr.right, indent, code_type),
            operator_expr_combine_strength > right_expr_combine_strength
                || (operator_expr_combine_strength == right_expr_combine_strength
                    && associativity == Associativity::LeftToRight),
        ))
}

fn conditional_operator_expr_to_string(
    conditional_operator: &data::ConditionalOperatorExpr,
    indent: &Indent,
    code_type: &data::CodeType,
) -> String {
    expr_to_string_with_combine_strength(
        CONDITIONAL_OPERATOR_COMBINE_STRENGTH,
        &conditional_operator.condition,
        indent,
        code_type,
    ) + "?"
        + &expr_to_string_with_combine_strength(
            CONDITIONAL_OPERATOR_COMBINE_STRENGTH,
            &conditional_operator.then_expr,
            indent,
            code_type,
        )
        + ":"
        + &expr_to_string_with_combine_strength(
            CONDITIONAL_OPERATOR_COMBINE_STRENGTH,
            &conditional_operator.else_expr,
            indent,
            code_type,
        )
}

fn call_expr_to_string(
    call_expr: &data::CallExpr,
    indent: &Indent,
    code_type: &data::CodeType,
) -> String {
    expr_to_string_with_combine_strength(
        CALL_OR_NEW_COMBINE_STRENGTH,
        &call_expr.expr,
        indent,
        code_type,
    ) + "("
        + &call_expr
            .parameter_list
            .iter()
            .map(|parameter| expr_to_string(parameter, indent, code_type))
            .collect::<Vec<String>>()
            .join(", ")
        + ")"
}

///
/// ```ts
/// list[0]
/// data.name
///  ```
/// の部分indexのExprがstringLiteralで識別子に使える文字なら`.name`のようになる
///
fn index_access_to_string(
    index_expr: &data::Expr,
    indent: &Indent,
    code_type: &data::CodeType,
) -> String {
    match index_expr {
        data::Expr::StringLiteral(string) if data::identifer::is_safe_property_name(string) => {
            String::from(".") + string
        }
        _ => String::from("[") + &expr_to_string(index_expr, indent, code_type) + "]",
    }
}

fn function_definition_statement_to_string(
    function_definition: &data::FunctionDefinitionStatement,
    indent: &Indent,
    code_type: &data::CodeType,
) -> String {
    String::from("const ")
        + &function_definition.name.get()
        + " = "
        + &type_parameter_list_to_string(&function_definition.type_parameter_list, code_type)
        + "("
        + &function_definition
            .parameter_list
            .iter()
            .map(|parameter| parameter.name.get() + &type_annotation(&parameter.r#type, code_type))
            .collect::<Vec<String>>()
            .join(", ")
        + ")"
        + &type_annotation(&function_definition.return_type, code_type)
        + " => "
        + &lambda_body_to_string(&function_definition.statement_list, indent, code_type)
        + ";"
}

fn switch_to_string(
    switch: &data::SwitchStatement,
    indent: &Indent,
    code_type: &data::CodeType,
) -> String {
    let case_indent = indent.add_one();
    String::from("switch (")
        + &expr_to_string(&switch.expr, indent, code_type)
        + ") {\n"
        + &switch
            .pattern_list
            .iter()
            .map(|pattern| {
                indent_number_to_string(&case_indent)
                    + "case "
                    + &string_literal_value_to_string(&pattern.case_string)
                    + ": "
                    + &statement_list_to_string(&pattern.statement_list, &case_indent, code_type)
            })
            .collect::<Vec<String>>()
            .join("\n")
        + "\n"
        + &indent_number_to_string(indent)
        + "}"
}

fn property_name_to_string(property_name: &str) -> String {
    if data::identifer::is_safe_property_name(property_name) {
        String::from(property_name)
    } else {
        string_literal_value_to_string(property_name)
    }
}

#[derive(Eq, PartialEq)]
pub enum Associativity {
    LeftToRight,
    RightToLeft,
}

fn binary_operator_associativity(binary_operator: &data::BinaryOperator) -> Associativity {
    match binary_operator {
        data::BinaryOperator::Exponentiation => Associativity::RightToLeft,
        data::BinaryOperator::Multiplication
        | data::BinaryOperator::Division
        | data::BinaryOperator::Remainder
        | data::BinaryOperator::Addition
        | data::BinaryOperator::Subtraction
        | data::BinaryOperator::LeftShift
        | data::BinaryOperator::SignedRightShift
        | data::BinaryOperator::UnsignedRightShift
        | data::BinaryOperator::LessThan
        | data::BinaryOperator::LessThanOrEqual
        | data::BinaryOperator::Equal
        | data::BinaryOperator::NotEqual
        | data::BinaryOperator::BitwiseAnd
        | data::BinaryOperator::BitwiseXOr
        | data::BinaryOperator::BitwiseOr
        | data::BinaryOperator::LogicalAnd
        | data::BinaryOperator::LogicalOr => Associativity::LeftToRight,
    }
}

fn vec_to_string<E, F>(result: &mut String, vec: &Vec<E>, func: F, separator: &str)
where
    F: Fn(&mut String, &E),
{
    let mut iter = vec.iter();
    match iter.next() {
        Some(item) => {
            func(result, item);
        }
        None => {
            return;
        }
    }
    for item in iter {
        result.push_str(separator);
        func(result, item);
    }
}
