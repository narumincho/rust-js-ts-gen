use crate::data;

#[derive(Copy, Clone)]
pub struct Indent {
    value: u16,
}

impl Indent {
    fn from(value: u16) -> Self {
        Indent { value }
    }

    fn addOne(self) -> Self {
        Indent {
            value: self.value + 1,
        }
    }
}

const ESLINT_DISABLE_COMMENT: &'static str =
    "/* eslint-disable */\n/* generated by js-ts-code-generator. Do not edit! */\n\n";

/// コードを文字列にする
pub fn to_string(code: data::Code, code_type: data::CodeType) -> String {
    String::from(ESLINT_DISABLE_COMMENT)
        + &(code
            .export_definition_list
            .iter()
            .map(|export_definition| export_definition_to_string(&export_definition, &code_type)))
        .collect::<Vec<String>>()
        .join("\n")
}

fn export_definition_to_string(
    export_definition: &data::ExportDefinition,
    code_type: &data::CodeType,
) -> String {
    match export_definition {
        data::ExportDefinition::TypeAlias(type_alias) => {
            type_alias_to_string(type_alias, code_type)
        }
        data::ExportDefinition::Function(function) => {
            export_function_to_string(function, code_type)
        }
        data::ExportDefinition::Variable(variable) => {
            export_variable_to_string(variable, code_type)
        }
    }
}

fn type_alias_to_string(type_alias: &data::TypeAlias, code_type: &data::CodeType) -> String {
    document_to_string(&type_alias.document)
        + "export type "
        + &data::identifer::get(&type_alias.name)
        + &type_parameter_list_to_string(&type_alias.type_parameter_list)
        + " = "
        + &type_to_string(&type_alias.r#type)
        + ";\n\n"
}

fn export_function_to_string(function: &data::Function, code_type: &data::CodeType) -> String {
    document_to_string(
        &(String::new()
            + &function.document
            + &parameter_list_to_document(&function.parameter_list)),
    ) + "export const "
        + &data::identifer::get(&function.name)
        + " = "
        + &type_parameter_list_to_string(&function.type_parameter_list)
        + "("
        + &function
            .parameter_list
            .iter()
            .map(|parameter| {
                data::identifer::get(&parameter.name) + ": " + &type_to_string(&parameter.r#type)
            })
            .collect::<Vec<String>>()
            .join(", ")
        + "): "
        + &type_to_string(&function.return_type)
        + " => "
        + &lambdaBody_to_string(&function.statement_list, &Indent::from(0), code_type)
        + ";\n\n"
}

fn export_variable_to_string(variable: &data::Variable, code_type: &data::CodeType) -> String {
    document_to_string(&variable.document)
        + "export const "
        + &data::identifer::get(&variable.name)
        + &type_annotation(&variable.r#type, code_type)
        + " = "
        + &expr_to_string(&variable.expr, &Indent::from(0), code_type)
        + ";\n\n"
}

fn document_to_string(document: &str) -> String {
    let trimmed = document.trim();
    if trimmed.is_empty() {
        String::new()
    } else {
        String::from("\n/**\n")
            + &trimmed
                .lines()
                .map(|line| {
                    if line.is_empty() {
                        String::from(" *")
                    } else {
                        String::from(" * ") + line
                    }
                })
                .collect::<Vec<String>>()
                .join("\n")
            + "\n */\n"
    }
}

fn parameter_list_to_document(parameter_list: &Vec<data::ParameterWithDocument>) -> String {
    if parameter_list.is_empty() {
        String::new()
    } else {
        String::from("\n")
            + &parameter_list
                .iter()
                .map(|parameter| {
                    if parameter.document.is_empty() {
                        String::new()
                    } else {
                        String::from("@param ")
                            + &data::identifer::get(&parameter.name)
                            + " "
                            + &parameter.document
                    }
                })
                .collect::<Vec<String>>()
                .join("\n")
    }
}

/// 型パラメーターを文字列にする
///
/// - `<T extends unknown>`
/// - `<ok extends unknown, error extends unknown>`
///
///
/// extends unknown をつけた理由はJSXでも解釈できるようにするため
fn type_parameter_list_to_string(type_parameter_list: &Vec<data::identifer::Identifer>) -> String {
    if type_parameter_list.is_empty() {
        String::new()
    } else {
        String::from("<")
            + &type_parameter_list
                .iter()
                .map(|type_parameter| data::identifer::get(type_parameter) + " extends unknown")
                .collect::<Vec<String>>()
                .join(", ")
            + ">"
    }
}

fn type_to_string(r#type: &data::Type) -> String {
    match r#type {
        data::Type::Number => String::from("number"),

        data::Type::String => String::from("string"),

        data::Type::Boolean => String::from("boolean"),

        data::Type::Null => String::from("null"),

        data::Type::Never => String::from("never"),

        data::Type::Void => String::from("void"),

        data::Type::Undefined => String::from("undefined"),

        data::Type::Object(member_list) => type_object_to_string(&**member_list),

        data::Type::Function(function_type) => type_function_to_string(function_type),

        data::Type::Union(type_list) => type_list
            .iter()
            .map(|pattern| type_to_string(pattern))
            .collect::<Vec<String>>()
            .join(" | "),

        data::Type::Intersection(intersection_type) => {
            type_to_string(&intersection_type.left)
                + " & "
                + &type_to_string(&intersection_type.right)
        }

        data::Type::WithTypeParameter(type_with_parameter) => {
            type_to_string(&type_with_parameter.r#type)
                + &(if type_with_parameter.type_parameter_list.is_empty() {
                    String::new()
                } else {
                    String::from("<")
                        + &type_with_parameter
                            .type_parameter_list
                            .iter()
                            .map(|typeParameter| type_to_string(typeParameter))
                            .collect::<Vec<String>>()
                            .join(", ")
                        + ">"
                })
        }

        data::Type::ScopeInFile(identifer) => data::identifer::get(identifer),

        data::Type::ScopeInGlobal(identifer) => data::identifer::get(identifer),
        data::Type::ImportedType(imported_type) => {
            String::from("$$$")
                + &imported_type.module_name
                + "."
                + &data::identifer::get(&imported_type.name)
        }

        data::Type::StringLiteral(string) => string_literal_value_to_string(string),
    }
}

fn lambdaBody_to_string(
    statement_list: &Vec<data::Statement>,
    indent: &Indent,
    code_type: &data::CodeType,
) -> String {
    match statement_list.first() {
        Some(data::Statement::Return(expr)) if statement_list.len() == 1 => {
            expr_to_string_with_combine_strength(
                &data::Expr::Lambda(Box::new(data::LambdaExpr {
                    type_parameter_list: vec![],
                    parameter_list: vec![],
                    return_type: data::Type::Void,
                    statement_list: vec![],
                })),
                expr,
                indent,
                code_type,
            )
        }
        _ => statement_list_to_string(statement_list, indent, code_type),
    }
}

fn expr_to_string(expr: &data::Expr, indent: &Indent, code_type: &data::CodeType) -> String {
    match expr {
        data::Expr::NumberLiteral(int32) => format!("{}", int32),

        data::Expr::StringLiteral(string) => string_literal_value_to_string(string),

        data::Expr::BooleanLiteral(true) => String::from("true"),

        data::Expr::BooleanLiteral(false) => String::from("false"),

        data::Expr::UndefinedLiteral => String::from("undefined"),

        data::Expr::NullLiteral => String::from("null"),

        data::Expr::ArrayLiteral(array_item) => {
            array_literal_to_string(array_item, indent, code_type)
        }

        data::Expr::ObjectLiteral(member_list) => {
            object_literal_to_string(member_list, indent, code_type)
        }

        data::Expr::UnaryOperator(unary_operatorExpr) => {
            unary_operator_to_string(&unary_operatorExpr.operator)
                + &expr_to_string_with_combine_strength(
                    expr,
                    &unary_operatorExpr.expr,
                    indent,
                    code_type,
                )
        }
        data::Expr::BinaryOperator(binaryOperatorExpr) => {
            binary_operator_expr_to_string(binaryOperatorExpr, indent, code_type)
        }

        data::Expr::ConditionalOperator(conditional_operator_expr) => {
            conditional_operator_expr_to_string(conditional_operator_expr, indent, code_type)
        }

        data::Expr::Lambda(lambda) => {
            type_parameter_list_to_string(&lambda.type_parameter_list)
                + "("
                + &lambda
                    .parameter_list
                    .iter()
                    .map(|parameter| {
                        data::identifer::get(&parameter.name)
                            + &type_annotation(&parameter.r#type, code_type)
                    })
                    .collect::<Vec<String>>()
                    .join(", ")
                + ")"
                + &type_annotation(&lambda.return_type, code_type)
                + " => "
                + &lambdaBody_to_string(&lambda.statement_list, indent, code_type)
        }

        data::Expr::Variable(identifer) => data::identifer::get(identifer),

        data::Expr::GlobalObjects(identifer) => data::identifer::get(identifer),
        data::Expr::ImportedVariable(imported_variable) => {
            String::from("$$$")
                + &imported_variable.module_name
                + "."
                + &data::identifer::get(&imported_variable.name)
        }

        data::Expr::Get(get_expr) => {
            expr_to_string_with_combine_strength(expr, &get_expr.expr, indent, code_type)
                + &index_access_to_string(&get_expr.propertyExpr, indent, code_type)
        }

        data::Expr::Call(call_expr) => call_expr_to_string(expr, call_expr, indent, code_type),

        data::Expr::New(call_expr) => {
            String::from("new ") + &call_expr_to_string(expr, call_expr, indent, code_type)
        }

        data::Expr::TypeAssertion(type_assertion) => {
            expr_to_string(&type_assertion.expr, indent, code_type)
                + " as "
                + &type_to_string(&type_assertion.r#type)
        }
    }
}

fn expr_to_string_with_combine_strength(
    expr: &data::Expr,
    target: &data::Expr,
    indent: &Indent,
    code_type: &data::CodeType,
) -> String {
    todo!()
}

fn statement_list_to_string(
    statement_list: &Vec<data::Statement>,
    indent: &Indent,
    code_type: &data::CodeType,
) -> String {
    String::from("{\n")
        + &statement_list
            .iter()
            .map(|statement| statement_to_string(statement, &indent.addOne(), code_type))
            .collect::<Vec<String>>()
            .join("\n")
        + "\n"
        + &indent_number_to_string(indent)
        + "}"
}

fn statement_to_string(
    statement: &data::Statement,
    indent: &Indent,
    code_type: &data::CodeType,
) -> String {
    todo!()
}

fn indent_number_to_string(indent: &Indent) -> String {
    String::from("  ").repeat(indent.value as usize)
}

/**
 * codeTypeがTypeScriptだった場合,`: string`のような型注釈をつける
 */
fn type_annotation(r#type: &data::Type, code_type: &data::CodeType) -> String {
    match code_type {
        data::CodeType::JavaScript => String::new(),
        data::CodeType::TypeScript => String::from(": ") + &type_to_string(&r#type),
    }
}

fn type_object_to_string(member_list: &Vec<data::MemberType>) -> String {
    todo!()
}

fn type_function_to_string(function: &data::FunctionType) -> String {
    todo!()
}

fn string_literal_value_to_string(string: &str) -> String {
    String::from("\"")
        + &string
            .replace("\\", "\\\\")
            .replace("\"", "\\\"")
            .replace("\n", "\\n")
        + "\""
}

#[test]
fn test_escape_in_string_literal() {
    assert_eq!(
        string_literal_value_to_string("\\ a \n \"\""),
        String::from("\"\\\\ a \\n \\\"\\\"\"")
    )
}

fn array_literal_to_string(
    item_list: &Vec<data::ArrayItem>,
    indent: &Indent,
    code_type: &data::CodeType,
) -> String {
    String::from("[")
        + &item_list
            .iter()
            .map(|item| {
                String::from(if item.spread { "..." } else { "" })
                    + &expr_to_string(&item.expr, indent, code_type)
            })
            .collect::<Vec<String>>()
            .join(", ")
        + "]"
}

fn object_literal_to_string(
    member_list: &Vec<data::Member>,
    indent: &Indent,
    code_type: &data::CodeType,
) -> String {
    String::from("{ ")
        + &member_list
            .iter()
            .map(|member| match member {
                data::Member::Spread(expr) => {
                    String::from("...") + &expr_to_string(expr, indent, code_type)
                }

                data::Member::KeyValue(data::KeyValue {
                    key,
                    value: data::Expr::Variable(value_identifer),
                }) if *key == data::identifer::get(value_identifer) => key.clone(),
                data::Member::KeyValue(data::KeyValue { key, value }) => {
                    (if data::identifer::is_safe_property_name(key) {
                        key.clone()
                    } else {
                        string_literal_value_to_string(key)
                    }) + ": "
                        + &expr_to_string(value, indent, code_type)
                }
            })
            .collect::<Vec<String>>()
            .join(", ")
        + " "
        + "}"
}

fn unary_operator_to_string(unary_operator: &data::UnaryOperator) -> String {
    todo!()
}

fn binary_operator_expr_to_string(
    binary_operator_expr: &data::BinaryOperatorExpr,
    indent: &Indent,
    code_type: &data::CodeType,
) -> String {
    todo!()
}

fn conditional_operator_expr_to_string(
    conditional_operator: &data::ConditionalOperatorExpr,
    indent: &Indent,
    code_type: &data::CodeType,
) -> String {
    todo!()
}

fn call_expr_to_string(
    expr: &data::Expr,
    call_expr: &data::CallExpr,
    indent: &Indent,
    code_type: &data::CodeType,
) -> String {
    todo!()
}

fn index_access_to_string(
    expr: &data::Expr,
    indent: &Indent,
    code_type: &data::CodeType,
) -> String {
    todo!()
}
