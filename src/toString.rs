use crate::data;

const ESLINT_DISABLE_COMMENT: &'static str =
    "/* eslint-disable */\n/* generated by js-ts-code-generator. Do not edit! */\n\n";

/// コードを文字列にする
pub fn to_string(code: data::Code, code_type: data::CodeType) -> String {
    String::from(ESLINT_DISABLE_COMMENT)
        + &(code
            .export_definition_list
            .iter()
            .map(|export_definition| export_definition_to_string(&export_definition, &code_type)))
        .collect::<Vec<String>>()
        .join("\n")
}

fn export_definition_to_string(
    export_definition: &data::ExportDefinition,
    code_type: &data::CodeType,
) -> String {
    match export_definition {
        data::ExportDefinition::TypeAlias(type_alias) => {
            type_alias_to_string(type_alias, code_type)
        }
        data::ExportDefinition::Function(function) => {
            export_function_to_string(function, code_type)
        }
        data::ExportDefinition::Variable(variable) => {
            export_variable_to_string(variable, code_type)
        }
    }
}

fn type_alias_to_string(type_alias: &data::TypeAlias, code_type: &data::CodeType) -> String {
    document_to_string(&type_alias.document)
        + "export type "
        + &data::identifer::get(&type_alias.name)
        + &type_parameter_list_to_string(&type_alias.type_parameter_list)
        + " = "
        + &type_to_string(&type_alias.r#type)
        + ";\n\n"
}

fn export_function_to_string(function: &data::Function, code_type: &data::CodeType) -> String {
    document_to_string(
        &(String::new()
            + &function.document
            + &parameter_list_to_document(&function.parameter_list)),
    ) + "export const "
        + &data::identifer::get(&function.name)
        + " = "
        + &type_parameter_list_to_string(&function.type_parameter_list)
        + "("
        + &function
            .parameter_list
            .iter()
            .map(|parameter| {
                data::identifer::get(&parameter.name) + ": " + &type_to_string(&parameter.r#type)
            })
            .collect::<Vec<String>>()
            .join(", ")
        + "): "
        + &type_to_string(&function.return_type)
        + " => "
        + &lambdaBody_to_string(&function.statement_list, 0, code_type)
        + ";\n\n"
}

fn export_variable_to_string(variable: &data::Variable, code_type: &data::CodeType) -> String {
    document_to_string(&variable.document)
        + "export const "
        + &data::identifer::get(&variable.name)
        + &type_annotation(&variable.r#type, code_type)
        + " = "
        + &expr_to_string(&variable.expr, 0, code_type)
        + ";\n\n"
}

fn document_to_string(document: &str) -> String {
    let trimmed = document.trim();
    if trimmed.is_empty() {
        String::new()
    } else {
        String::from("\n/**\n")
            + &trimmed
                .lines()
                .map(|line| {
                    if line.is_empty() {
                        String::from(" *")
                    } else {
                        String::from(" * ") + line
                    }
                })
                .collect::<Vec<String>>()
                .join("\n")
            + "\n */\n"
    }
}

fn parameter_list_to_document(parameter_list: &Vec<data::ParameterWithDocument>) -> String {
    if parameter_list.is_empty() {
        String::new()
    } else {
        String::from("\n")
            + &parameter_list
                .iter()
                .map(|parameter| {
                    if parameter.document.is_empty() {
                        String::new()
                    } else {
                        String::from("@param ")
                            + &data::identifer::get(&parameter.name)
                            + " "
                            + &parameter.document
                    }
                })
                .collect::<Vec<String>>()
                .join("\n")
    }
}

/// 型パラメーターを文字列にする
///
/// - `<T extends unknown>`
/// - `<ok extends unknown, error extends unknown>`
///
///
/// extends unknown をつけた理由はJSXでも解釈できるようにするため
fn type_parameter_list_to_string(type_parameter_list: &Vec<data::identifer::Identifer>) -> String {
    if type_parameter_list.is_empty() {
        String::new()
    } else {
        String::from("<")
            + &type_parameter_list
                .iter()
                .map(|type_parameter| data::identifer::get(type_parameter) + " extends unknown")
                .collect::<Vec<String>>()
                .join(", ")
            + ">"
    }
}

fn type_to_string(r#type: &data::Type) -> String {
    match r#type {
        data::Type::Number => String::from("number"),

        data::Type::String => String::from("string"),

        data::Type::Boolean => String::from("boolean"),

        data::Type::Null => String::from("null"),

        data::Type::Never => String::from("never"),

        data::Type::Void => String::from("void"),

        data::Type::Undefined => String::from("undefined"),

        data::Type::Object(member_list) => type_object_to_string(&**member_list),

        data::Type::Function(function_type) => type_function_to_string(function_type),

        data::Type::Union(type_list) => type_list
            .iter()
            .map(|pattern| type_to_string(pattern))
            .collect::<Vec<String>>()
            .join(" | "),

        data::Type::Intersection(intersection_type) => {
            type_to_string(&intersection_type.left)
                + " & "
                + &type_to_string(&intersection_type.right)
        }

        data::Type::WithTypeParameter(type_with_parameter) => {
            type_to_string(&type_with_parameter.r#type)
                + &(if type_with_parameter.type_parameter_list.is_empty() {
                    String::new()
                } else {
                    String::from("<")
                        + &type_with_parameter
                            .type_parameter_list
                            .iter()
                            .map(|typeParameter| type_to_string(typeParameter))
                            .collect::<Vec<String>>()
                            .join(", ")
                        + ">"
                })
        }

        data::Type::ScopeInFile(identifer) => data::identifer::get(identifer),

        data::Type::ScopeInGlobal(identifer) => data::identifer::get(identifer),
        data::Type::ImportedType(imported_type) => {
            String::from("$$$")
                + &imported_type.module_name
                + "."
                + &data::identifer::get(&imported_type.name)
        }

        data::Type::StringLiteral(string) => string_literal_value_to_string(string),
    }
}

fn lambdaBody_to_string(
    statement_list: &Vec<data::Statement>,
    indent: u16,
    code_type: &data::CodeType,
) -> String {
    match statement_list.first() {
        Some(data::Statement::Return(expr)) if statement_list.len() == 1 => {
            expr_to_string_with_combine_strength(
                &data::Expr::Lambda(Box::new(data::LambdaExpr {
                    type_parameter_list: vec![],
                    parameter_list: vec![],
                    return_type: data::Type::Void,
                    statement_list: vec![],
                })),
                expr,
                indent,
                code_type,
            )
        }
        _ => statement_list_to_string(statement_list, indent, code_type),
    }
}

fn expr_to_string(expr: &data::Expr, indent: u16, code_type: &data::CodeType) -> String {
    todo!()
}

fn expr_to_string_with_combine_strength(
    expr: &data::Expr,
    target: &data::Expr,
    indent: u16,
    code_type: &data::CodeType,
) -> String {
    todo!()
}

fn statement_list_to_string(
    statement_list: &Vec<data::Statement>,
    indent: u16,
    code_type: &data::CodeType,
) -> String {
    String::from("{\n")
        + &statement_list
            .iter()
            .map(|statement| statement_to_string(statement, indent + 1, code_type))
            .collect::<Vec<String>>()
            .join("\n")
        + "\n"
        + &indent_number_to_string(indent)
        + "}"
}

fn statement_to_string(
    statement: &data::Statement,
    indent: u16,
    code_type: &data::CodeType,
) -> String {
    todo!()
}

fn indent_number_to_string(indent: u16) -> String {
    String::from("  ").repeat(indent as usize)
}

/**
 * codeTypeがTypeScriptだった場合,`: string`のような型注釈をつける
 */
fn type_annotation(r#type: &data::Type, code_type: &data::CodeType) -> String {
    match code_type {
        data::CodeType::JavaScript => String::new(),
        data::CodeType::TypeScript => String::from(": ") + &type_to_string(&r#type),
    }
}

fn type_object_to_string(member_list: &Vec<data::MemberType>) -> String {
    todo!()
}

fn type_function_to_string(function: &data::FunctionType) -> String {
    todo!()
}

fn string_literal_value_to_string(string: &str) -> String {
    string.replace("\\", "\\\\")
}

#[test]
fn test_escape_in_string_literal() {
    assert_eq!(string_literal_value_to_string("\\"), String::from("\\\\"))
}
