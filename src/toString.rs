use crate::data;

const eslint_disable_comment: &'static str =
    "/* eslint-disable */\n/* generated by js-ts-code-generator. Do not edit! */\n\n";

/// コードを文字列にする
pub fn to_string(code: data::Code, code_type: data::CodeType) -> String {
    String::from(eslint_disable_comment)
        + &(code
            .export_definition_list
            .iter()
            .map(|export_definition| export_definition_to_string(&export_definition, &code_type)))
        .collect::<Vec<String>>()
        .join("\n")
}

fn export_definition_to_string(
    export_definition: &data::ExportDefinition,
    code_type: &data::CodeType,
) -> String {
    match export_definition {
        data::ExportDefinition::TypeAlias(type_alias) => {
            type_alias_to_string(type_alias, code_type)
        }
        data::ExportDefinition::Function(function) => {
            export_function_to_string(function, code_type)
        }
        data::ExportDefinition::Variable(variable) => {
            export_variable_to_string(variable, code_type)
        }
    }
}

fn type_alias_to_string(type_alias: &data::TypeAlias, code_type: &data::CodeType) -> String {
    document_to_string(&type_alias.document)
        + "export type "
        + &data::identifer::get(&type_alias.name)
        + &type_parameter_list_to_string(&type_alias.type_parameter_list)
        + " = "
        + &type_to_string(&type_alias.r#type)
        + ";\n\n"
}

fn export_function_to_string(function: &data::Function, code_type: &data::CodeType) -> String {
    document_to_string(
        &(String::new()
            + &function.document
            + &parameter_list_to_document(&function.parameter_list)),
    ) + "export const "
        + &data::identifer::get(&function.name)
        + " = "
        + &type_parameter_list_to_string(&function.type_parameter_list)
        + "("
        + &function
            .parameter_list
            .iter()
            .map(|parameter| {
                data::identifer::get(&parameter.name) + ": " + &type_to_string(&parameter.r#type)
            })
            .collect::<Vec<String>>()
            .join(", ")
        + "): "
        + &type_to_string(&function.return_type)
        + " => "
        + &lambdaBody_to_string(&function.statement_list, 0, code_type)
        + ";\n\n"
}

fn export_variable_to_string(variable: &data::Variable, code_type: &data::CodeType) -> String {
    document_to_string(&variable.document)
        + "export const "
        + &data::identifer::get(&variable.name)
        + ": "
        + &type_to_string(&variable.r#type)
        + " ="
        + &expr_to_string(&variable.expr, 0, code_type)
        + ";\n\n"
}

fn document_to_string(document: &str) -> String {
    let trimmed = document.trim();
    if trimmed.is_empty() {
        String::new()
    } else {
        String::from("\n/**\n")
            + &trimmed
                .lines()
                .map(|line| {
                    if line.is_empty() {
                        String::from(" *")
                    } else {
                        String::from(" * ") + line
                    }
                })
                .collect::<Vec<String>>()
                .join("\n")
            + "\n */\n"
    }
}

fn parameter_list_to_document(parameter_list: &Vec<data::ParameterWithDocument>) -> String {
    if parameter_list.is_empty() {
        String::new()
    } else {
        String::from("\n")
            + &parameter_list
                .iter()
                .map(|parameter| {
                    if parameter.document.is_empty() {
                        String::new()
                    } else {
                        String::from("@param ")
                            + &data::identifer::get(&parameter.name)
                            + " "
                            + &parameter.document
                    }
                })
                .collect::<Vec<String>>()
                .join("\n")
    }
}

fn type_parameter_list_to_string(type_parameter_list: &Vec<data::identifer::Identifer>) -> String {
    todo!();
}

fn type_to_string(type_: &data::Type) -> String {
    todo!()
}

fn lambdaBody_to_string(
    a: &Vec<data::Statement>,
    indent: u32,
    code_type: &data::CodeType,
) -> String {
    unimplemented!()
}

fn expr_to_string(expr: &data::Expr, indent: u32, code_type: &data::CodeType) -> String {
    todo!()
}
